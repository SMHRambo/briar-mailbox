import java.util.jar.JarEntry
import java.util.jar.JarFile
import java.util.jar.JarOutputStream

import static java.util.Collections.list

plugins {
    id 'application'
    id 'idea'
    id 'org.jetbrains.kotlin.jvm'
    id 'org.jetbrains.kotlin.kapt'
    id "org.jlleitschuh.gradle.ktlint" version "$ktlint_plugin_version"
    id 'checkstyle'
}

sourceCompatibility = 1.8
targetCompatibility = 1.8

configurations {
    tor
}

dependencies {
    implementation project(path: ':mailbox-core', configuration: 'default')

    implementation "ch.qos.logback:logback-classic:1.2.10"
    implementation 'com.github.ajalt:clikt:2.2.0'

    def jna_version = '5.8.0'
    implementation "net.java.dev.jna:jna:$jna_version"
    implementation "net.java.dev.jna:jna-platform:$jna_version"
    tor "org.briarproject:tor-linux:$tor_version"
    tor "org.briarproject:obfs4proxy-linux:$obfs4_version"

    implementation "com.google.dagger:hilt-core:$hilt_version"
    kapt "com.google.dagger:hilt-compiler:$hilt_version"

    testImplementation "org.junit.jupiter:junit-jupiter-api:$junit_version"
    testImplementation "org.junit.jupiter:junit-jupiter-params:$junit_version"
    testImplementation "org.junit.jupiter:junit-jupiter-engine:$junit_version"
    testImplementation "io.mockk:mockk:$mockk_version"
}

application {
    mainClass = 'org.briarproject.mailbox.cli.MainKt'
}

test {
    useJUnitPlatform()
    testLogging {
        events "passed", "skipped", "failed"
    }
}

apply from: "${rootProject.rootDir}/gradle/ktlint.gradle"

// At the moment for non-Android projects we need to explicitly mark the code generated by kapt
// as 'generated source code' for correct highlighting and resolve in IDE.
idea {
    module {
        sourceDirs += file('build/generated/source/kapt/main')
        testSourceDirs += file('build/generated/source/kapt/test')
        generatedSourceDirs += file('build/generated/source/kapt/main')
    }
}

def torBinariesDir = 'src/main/resources'

task cleanTorBinaries {
    doLast {
        delete fileTree(torBinariesDir) { include '*.zip' }
    }
}

clean.dependsOn cleanTorBinaries

task unpackTorBinaries {
    doLast {
        copy {
            from configurations.tor.collect { zipTree(it) }
            into torBinariesDir
        }
    }
    dependsOn cleanTorBinaries
}

processResources {
    inputs.dir torBinariesDir
    dependsOn unpackTorBinaries
}

void jarFactory(Jar jarTask, jarArchitecture) {
    jarTask.doFirst {
        println 'Building ' + jarArchitecture + ' version has started'
    }
    jarTask.manifest {
        attributes(
                'Main-Class': application.getMainClass()
        )
    }
    jarTask.setArchiveClassifier(jarArchitecture)
    jarTask.from {
        configurations.runtimeClasspath.collect { file ->
            file.isDirectory() ? file : zipTree(file)
        }
    } { copySpec ->
        copySpec.duplicatesStrategy(DuplicatesStrategy.EXCLUDE)
        String[] architectures = ["linux-aarch64", "linux-armhf", "linux-x86_64"]
        for (String arch : architectures) {
            if (arch != jarArchitecture) {
                exclude "obfs4proxy_" + arch + ".zip"
                exclude "tor_" + arch + ".zip"
            }
        }
        exclude 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA'
    }
    jarTask.with jar
    jarTask.doLast {
        // Rename the original jar
        File jar = getArchiveFile().get().getAsFile()
        String srcPath = jar.toString().replaceFirst('\\.jar$', '.unsorted.jar')
        File srcFile = new File(srcPath)
        jar.renameTo(srcFile)
        JarFile srcJarFile = new JarFile(srcFile)
        OutputStream destStream = new JarOutputStream(new FileOutputStream(jar))
        // Read and sort the entries
        Map<String, JarEntry> entries = new TreeMap<>()
        for (JarEntry e : list(srcJarFile.entries())) entries.put(e.getName(), e)
        // Write the sorted entries
        for (JarEntry srcEntry : entries.values()) {
            JarEntry destEntry = new JarEntry(srcEntry.getName())
            destEntry.setTime(0)
            destStream.putNextEntry(destEntry)
            InputStream srcStream = srcJarFile.getInputStream(srcEntry)
            int read
            byte[] buf = new byte[4096]
            while ((read = srcStream.read(buf, 0, buf.length)) != -1) {
                destStream.write(buf, 0, read)
            }
            destStream.closeEntry()
            srcStream.close()
        }
        destStream.close()
        srcJarFile.close()
        println 'Building ' + jarArchitecture + ' version has finished'
        println 'JAR: mailbox-cli/build/libs/mailbox-cli-linux-x86_64.jar'
    }
}

task x86LinuxJar(type: Jar) {
    group = "Build"
    description = "Assembles a runnable fat jar for x86-64 Linux"
    jarFactory(it, 'linux-x86_64')
}

tasks.withType(Test) {
    systemProperty 'java.library.path', 'libs'
}
