import java.util.jar.JarEntry
import java.util.jar.JarFile
import java.util.jar.JarOutputStream

import static java.util.Collections.list

plugins {
    id 'application'
    id 'idea'
    id 'org.jetbrains.kotlin.jvm'
    id 'org.jetbrains.kotlin.kapt'
    id "org.jlleitschuh.gradle.ktlint" version "$ktlint_plugin_version"
}

sourceCompatibility = 1.8
targetCompatibility = 1.8

dependencies {
    implementation project(path: ':mailbox-core', configuration: 'default')
    implementation project(path: ':mailbox-lib', configuration: 'default')

    implementation "ch.qos.logback:logback-classic:1.4.5"
    implementation 'com.github.ajalt:clikt:2.2.0'

    kapt "com.google.dagger:hilt-compiler:$hilt_version"

    testImplementation "org.junit.jupiter:junit-jupiter-api:$junit_version"
    testImplementation "org.junit.jupiter:junit-jupiter-params:$junit_version"
    testImplementation "org.junit.jupiter:junit-jupiter-engine:$junit_version"
    testImplementation "io.mockk:mockk:$mockk_version"
}

application {
    mainClass = 'org.briarproject.mailbox.cli.MainKt'
}

test {
    useJUnitPlatform()
    testLogging {
        events "passed", "skipped", "failed"
    }
}

apply from: "../gradle/ktlint.gradle"

// At the moment for non-Android projects we need to explicitly mark the code generated by kapt
// as 'generated source code' for correct highlighting and resolve in IDE.
idea {
    module {
        sourceDirs += file('build/generated/source/kapt/main')
        testSourceDirs += file('build/generated/source/kapt/test')
        generatedSourceDirs += file('build/generated/source/kapt/main')
    }
}

void jarFactory(Jar jarTask, os, architecture, configuration) {
    def jarArchitecture = os + "-" + architecture
    jarTask.doFirst {
        println 'Building ' + jarArchitecture + ' version has started'
    }
    jarTask.manifest {
        attributes(
                'Main-Class': application.getMainClass()
        )
    }
    jarTask.setArchiveClassifier(jarArchitecture)
    jarTask.from {
        configuration.collect { file ->
            file.isDirectory() ? file : zipTree(file)
        }
    } { copySpec ->
        copySpec.duplicatesStrategy(DuplicatesStrategy.EXCLUDE)
        String[] architectures = ["aarch64", "armhf", "x86_64"]
        for (String arch : architectures) {
            if (arch != architecture) {
                exclude arch + "/obfs4proxy"
                exclude arch + "/tor"
                exclude arch + "/snowflake"
            }
        }
        exclude 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA'
    }
    jarTask.with jar
    jarTask.doLast {
        // Rename the original jar
        File jar = getArchiveFile().get().getAsFile()
        String srcPath = jar.toString().replaceFirst('\\.jar$', '.unsorted.jar')
        File srcFile = new File(srcPath)
        jar.renameTo(srcFile)
        JarFile srcJarFile = new JarFile(srcFile)
        OutputStream destStream = new JarOutputStream(new FileOutputStream(jar))
        // Read and sort the entries
        Map<String, JarEntry> entries = new TreeMap<>()
        for (JarEntry e : list(srcJarFile.entries())) entries.put(e.getName(), e)
        // Write the sorted entries
        for (JarEntry srcEntry : entries.values()) {
            JarEntry destEntry = new JarEntry(srcEntry.getName())
            destEntry.setTime(0)
            destStream.putNextEntry(destEntry)
            InputStream srcStream = srcJarFile.getInputStream(srcEntry)
            int read
            byte[] buf = new byte[4096]
            while ((read = srcStream.read(buf, 0, buf.length)) != -1) {
                destStream.write(buf, 0, read)
            }
            destStream.closeEntry()
            srcStream.close()
        }
        destStream.close()
        srcJarFile.close()
        println 'Building ' + jarArchitecture + ' version has finished'
        println 'JAR: mailbox-cli/build/libs/mailbox-cli-' + jarArchitecture + '.jar'
    }
}

task x86LinuxJar(type: Jar) {
    group = "Build"
    description = "Assembles a runnable fat jar for x86-64 Linux"
    jarFactory(it, 'linux', 'x86_64', configurations.runtimeClasspath)
}

task aarch64LinuxJar(type: Jar) {
    group = "Build"
    description = "Assembles a runnable fat jar for AArch64 Linux"
    jarFactory(it, 'linux', 'aarch64', configurations.runtimeClasspath)
}

tasks.withType(Test) {
    systemProperty 'java.library.path', 'libs'
}
